{% extends "base.html.twig" %}

{% block title %}About{% endblock %}

{% block body %}
    <div class="grid-container">
        <div class="left-column">
            <h1 id="kmom01">Kmom01</h1>
            <p>Mina förkunskaper är grundade i det som vi har lärt oss från tidigare kurser i Webbprogrammering distans, dvs det från JavaScript och Objectorienterad Python.</p>
            <p>Det är en liten tröskel i att börja lära sig arbeta objectorienterat upplever jag, 
            men när man väl kommer in i det så är det ett logiskt och effektivt arbetssätt.
            Inför den här kursen så känner jag mig hyfsat bekväm att jobba objektorienterat 
            men det kommer troligtvis (och förhoppningsvis) vara en del man behöver lära sig.</p>
            <p>För PHPs modell för klasser och objekt så arbetar man med ett objekt som man skapar med en klass. Varje objekt är en instans av klassen och har vissa egenskaper (propertires).</p>
            <p>Ett objekt kan vara en stol, en bil, en person, allt möjligt, och de fungerar på olika sätt.</p>
            <p>I objektklassen finns även metoder (funktioner) som man kan anropa. Metoderna tillhör objektet och är klasspecifika.</p>
            <p>Kodbasen som användes för me/report blir som grunden för en hemsida där man kan samla olika funktioner på hemsidan på olika ställen</p>
            <p>När man sen använder "npm run build" så bygger den hemsidans struktur utifrån de parametrar som getts</p>
            
            <p>
            Parametrarna är indelade i tre stora kategorier.
            Model förmedlar datan till hemsidan och kommunicerar med View och Controller, men är inte lika beroende utav dem.
            View blir template-filerna bland annat i denna struktur, och utgörs av hur sidan ser ut snarare än hur den fungerar.
            Controller är PHP-filerna (eller filen) som innehåller olika routes och tar emot information från den som använder hemsidan.
            </p>
            
            <p>
            Från artikeln: "The Right Way", så var det intressant att läsa att PHP fungerar med rekursion men mest fokuserar på iteration. 
            Jag undrar vad som är fördelarna med respektive, då eftersom vi fokuserade en stor del på rekursion i objektorienterade Pythonkursen.
            Det ska bli intressant att lära sig om skillnader i sättet att arbeta mellan två objektorienterade språk.
            </p>

            <p>TIL för detta momentet var att instsallera Symfony och att få identifiera de mer centrala delarna i ramverket,
            alltså, de delar som man arbetar mest med. Har också lärt mig att felsöka routrar i Terminalen!</p>
            <p></p>

            <h1 id="kmom02">Kmom02</h1>
            <p>Man börjar få en större överblick av hur ramverket håller ihop en applikation och vi har testat lite andra funktioner och andra controllers i detta kursmoment. 
                Det man har fått upp ögonen för i det här momentet är att man nu kan bygga på olika applikationer utifrån samma MVC-ramverk och struktur som vi har jobbat med. 
                Vi börjar skapa oss ett skelett, en struktur, en stomme, en husgrund där vi undersöker hur el vatten och avlopp rör sig, 
                för att sedan kunna bygga flera olika hus i alla dess storlekar och sorter.</p>
            <p>
                De objektorienterade konstruktionerna arv, komposition, interface och trait fungerar som följande:
            </p>
            <p>
                Arv objektorienterad programmering använder man klasser för att ”bygga upp” sin kod och där fyller arv funktionen, 
                att man kan bygga vidare på att en klass utan att behöva om själva grundklassen och man kan då återanvända kod som finns i grundklassen till det den klassen som ärver. 
                En viktig distinktion är att klasser som ärver inte kan existera utan den kod som de ärver ifrån.
            </p>
            <p>
                Komposition är när en klass använder en annan klass men där den första klassen fortfarande kan existera utan den klassen som den använder kompositionsmässigt.
            </p>
            <p>
                Interface är ett ”löfte” om att en klass kommer behöva använda alla funktionen som finns i interfacet och får ett felmeddelande om detta krav ej uppfylls.
            </p>
            <p>
                Trait är som ett löst arv, den utgör bara olika funktioner eller attribut som kan återanvändas, men som inte är beroende på samma sätt som arv och komposition.
            </p>
            <p> 
                Jag löste uppgiften genom att först göra en controller för Cards, där jag lånade skelettet från Pig-övningen och gjorde om vissa delar, 
                bland annat strukturen på kort-klassen som behövde ha ett value och en suit. 
                Suit sparade jag som ett trait, för det var något som jag visste kommer användas om och om igen. 
            </p>
            <p>
                Jag hoppade över att spara allt i session för det jag mycket problem med det, bland annat hur jag skulle radera sessionen och som jag inte hittade något exempel av i pig-övningen, så det gick åt mycket tid åt att leta efter det. Istället hårdkodade jag in data för kortens värde och utgick från det. Sen skapade jag en till kontroller för JSON-api: och skapade routerna med det. Satt länge och förstod inte varför inte POST-fungerade tills jag såg att man behövde ett formulär för det och då löste jag det och sen fungerade det. Ibland lär man sig den hårda vägen :) 
                Nu tog det väldigt mycket tid att hitta lösningar för allting så det som är klart är i det enklaste fallet, men jag var i alla fall nöjd med att det fungerar så pass bra. Förbättringspotential skulle kunna vara för hur man hanterar session och ha det mer strukturerat, kanske i en egen funktion i deck-klassen, nu var det lite spretigt. Och man kan också rensa bort många funktioner och kod som jag inte använde i slutändan. 
                Så här långt med Symfony är det ett välstrukturerat och logiskt sätt att jobba med olika vyer, controllers och models. Just så här i början är det spretigt, det känns som ett ramverk som har relativt hög tröskel att komma in i men som man ser potentialen med att skapa program. Det är skillnad på det som visas i json-strukturen och det som sparas i Session, och det skulle man kunna förbättra för tydlighetens skull med några funktioner så man lättare kan spara bägge i samma struktur. 
            </p>
            <p>
                TIL för detta moment var nog mycket hur API:er fungerar och hur man strukturerar upp det som vi gjorde i kontrollerna. Det är TIL, och så att POST-metoder måste ha formulär. 
            </p>

            <h1 id="kmom03">Kmom03</h1>
            <p>
                Att strukturera upp med flödesdiagram och pseudokod hjälpte att få hjärnan i ”banan” på hur man skulle tänka, 
                men trots att det hjälpte så upplevde jag det inte som några jättestora skillnader mot hur det hade varit att inte ha det. 
                Dock så kan det dock vara annorlunda när det är ett större projekt för att hjälpa till att få översikt över vad man ska göra, 
                så jag tror absolut att jag kommer att använda det mycket i framtiden. Min problematik ligger mest i att tänka vart och i vilka modeller, 
                controller och vyer jag ska placera min kod, samt vilka delar ska ansvara för vad. Det är en process och jag känner att jag blir successivt bättre på det. 
            </p>
            <p>
                Min implementation landade slutligen i att göra en BlackJack klass som fick ha hand om logiken för spelet där jag placerade alla variabler, 
                klasser och funktioner för spelets gång. 
                Fördelarna var att jag kunde skapa ett json-objekt för varje gång jag behövde spara det i session, 
                likt det vi gjorde med Yahtzee-spelet i OO Python-kursen, så det var smidigt. Är nöjd med det upplägget och kände också att jag fick till aningen ”lös kod”, 
                det vill säga att klasserna inte är avhängiga varandra för mycket utan enkelt kan konfigureras. 
            </p>
            <p>
                Är också nöjd med att jag gjorde många ”små funktioner” som hade ett ansvarsområde, vilket gjorde det enkelt att hantera, 
                få en översikt om, och också ändra när något gick fel. Förbättringspotentialen i min kod är nog, som jag kom på i efterhand, 
                att jag kunde gjort en slags abstrakt ”container-class” som både CardHand och BlackJack kunde ärva av. Eller möjligtvis traits. 
                De bägge klasserna hade många likheter med att sätta in och returnera kort, de är båda huvudsakligen arrayer som lagrar kort-objekt så man hade kunnat göra en bra 
                gemensam lösning där men när jag väl kom på det så var jag så långt gången i kodandet att jag lät det vara som det är nu. Jaja, nästa gång!
            </p>
            <p>
                Överlag är känslan för Symfony att man börjar få koll på det nu efter tredje kursmomentet och det är ett naturligt och enkelt sätt att hantera koden genom att dela upp det i MVC. 
                Lite problematiskt med lintsen fortfarande och konfigurationen är något jag lär mig fortfarande. 
            </p>
            <p>
                TIL för detta kmom måste nog vara överlag en större förståelse för JSON och hur man kan arbeta med det, trots att övningen inte var så fokuserad på JSON. 
                Annars har jag lärt mig mer om PHP och klasshantering, till exempel hur jag skapar objekt från JSON i php, 
                hur jag kallar på olika metoder i klasserna och hur klasserna hänger ihop med varandra. 
                Det kändes som att det vi jobbade med förra momentet (kmom02) fick större betydelse i detta moment. Har också lärt mig mer att jobba med git. Det blev några TIL…
            </p>
            <p>
            

            <h1 id="kmom04">Kmom04</h1>
            <p>
            Det är bra med testning för då får man också mer koll på sina klasser, namespace och ett helikopterperspektiv som är mycket trevligt, 
            mer givande än UML-diagram eller flödesschema upplever jag för att strukturera upp koden. 
            PHPUnit gick enkelt att installera och fungerar bra som verktyg rent allmänt, det är enkelt att använda och testresultaten är tydliga.
            Det är också smidigt att den känner av alla tester och nu i efterhand så har det varit ett bra verktyg att kontrollera att koden funderar som den ska när man ska refaktorera koden från de felmeddelanden man har fått i linten. 
            </p>
            <p>
            Jag lyckades uppnå 100% för Dice och Card. Sen valde jag att lägga BlackJack under ett eget namespace, något som jag ångrar lite nu, 
            men där fick jag 75% kodtäckning så det är helt okej. Jag upptäcker mer och mer att koden jag skrivit själv är svårare att testa och att vissa 
            metoder blir mer komplexa och svårare att testa, det är en insikt till framtiden om att skriva enklare kod och försöka att inte väva in så mycket 
            kod i sig själv, om man uttrycker sig så. 
            </p>
            <p>
            Jag skrev om vissa delar av koden men ville inte ändra för mycket med risk för att jag också ändrar funktionaliteten 
            för koden och hur den är uppbyggd, att det slår ”slint” någon annanstans för att jag ändrade. Men vissa delar kunde jag ändra 
            och testade samtidigt så att det var fel, andra delar kunde jag inte ändra även om jag försökte, och klurar fortfarande på hur jag ska lösa dem. 
            Jag märkte också att vissa delar kunde testningen tycka var okej, men linten säga till och då när jag ändrade enligt linten så fick koden en helt 
            annan funktionalitet och testningen fungerade inte alls. Då kunde det också vara svårt att veta om det var testet som var skrivet korrekt eller om 
            det var koden som var fel från början. Hur som helst så gav det en insikt om att skriva bra tester som man är säker att de testar det som man vill åt. 
            </p>
            <p>

            Tror också definitivt att det hör ihop med snygg och ren kod. Testbar kod är lätt att läsa, inte komplicerad, uppdelad och ”luftig”, 
            förenklad så till den grad det går. Upplever också att testbar kod är lättare att läsa, och har man 3 if-satser på raken så 
            kanske man kan skriva om det till något bättre. 
            </p>
            <p>
            TIL för detta kmom var att lära mig använda linten bättre och att installera X-bug. 
            Det var några extra steg för mig som kör Mac, men löste det till slut med hjälp av instruktionerna som fanns på X-bugs hemsida. 
            Har också fått större förståelse och insikt i vilka fördelar som finns med att skriva kod som är enkel, små funktioner och som gör en sak i taget.
            </p>


        <h1 id="kmom07">Kmom07</h1>
        <p>

        </p>


        </div>
        <div class="right-column">
            <a href="{{ path('report') }}#kmom01">Kmom01</a>
            <a href="{{ path('report') }}#kmom02">Kmom02</a>
            <a href="{{ path('report') }}#kmom03">Kmom03</a>
            <a href="{{ path('report') }}#kmom04">Kmom04</a>
            <a href="{{ path('report') }}#kmom05">Kmom05</a>
            <a href="{{ path('report') }}#kmom06">Kmom06</a>
            <a href="{{ path('report') }}#kmom07">Kmom07</a>
        </div>
    </div>
{% endblock %}
